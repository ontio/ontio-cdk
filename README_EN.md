[![Build Status](https://travis-ci.com/laizy/ontio-cdk.svg?branch=master)](https://travis-ci.com/laizy/ontio-cdk)

English | [中文](README.md)

`ontio-cdk` is a suite of WebAssembly smart contract tools for developing ontology using rust, including a standard library for contract writing, a runtime api for chain interaction, and a plugin for the contract interface abi.
Contract testing framework, etc.

## Build development environment

1. install [rustup](https://rustup.rs/), 
Non-windows environment can be directly execute the following code：
```
curl https://sh.rustup.rs -sSf | sh
```
2. Install the rust compiler
```
rustup install nightly
```
And set the default to compile with nightly version
```
rustup default nightly
```
3. Install the wasm32 compilation target
```
rustup target add wasm32-unknown-unknown
```
4. Integrated Development Environment

Choose programming ide or editor according to personal preferences, such as IntelliJ, VSCode, vim, etc.

## How to write contract

1. create a project
```
cargo new --lib mycontract
```

2. edit `Cargo.toml`，add `ontio-cdk` dependencies

```toml
[package]
name = "mycontract"
version = "0.1.0"
authors = ["laizy <aochyi@126.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"] #Compile as a dynamic link library

[dependencies]
ontio-std = {git = "https://github.com/laizy/ontio-cdk"}

[features]
mock = ["ontio-std/mock"]
```
3. Develop a contract in `src/lib.rs`, the basic structure of the contract is as follows：

```rust
#![no_std]
use ontio_std::runtime;

// The entry function of the contract, using no_mangle to make it a derivative function of the wasm contract after compilation.
#[no_mangle]
pub fn invoke() {
    runtime::ret(b"hello, world");
}
```

4. compile contract：
```
cargo build --release --target wasm32-unknown-unknown
```

## Code generation macro

The contract is usually written from the byte array of the input parameter to parse the specific call method and call parameters, then jump to the corresponding function to execute, and finally serialize the execution result into a byte array return. This is similar to how the web server retrieves the byte stream from the network, parses out the specific request, executes the corresponding handler function, and serializes the result into a byte stream that is sent back to the network. Therefore, such fixed and cumbersome work can be handled in the same way as the web development framework, so that the contract developers focus on the development of the contract itself. `ontio_std` provides code generation macros that automatically generate auxiliary code at compile time based on the contract interface. The basic contract structure of a code generation macro is as follows:

```rust
#[ontio_std::abi_codegen::contract]
pub trait MyToken {
    //Define the external interface of the contract
    fn initialize(&mut self, owner: &Address) -> bool;
    fn name(&self) -> String;
    fn balance_of(&self, owner: &Address) -> U256;
    fn transfer(&mut self, from: &Address, to: &Address, amount: U256) -> bool;
    fn approve(&mut self, approves: &Address, receiver: &Address, amount:U256) -> bool;
    fn transfer_from(&mut self, receiver: &Address,approves: &Address, amount:U256) -> bool;
    fn allowance(&mut self, approves: &Address, receiver: &Address) -> U256;
    fn total_supply(&self) -> U256;

    //defining Event of the contract
    #[event]
    fn Transfer(&self, from: &Address, to: &Address, amount: U256) {}
    #[event]
    fn Approve(&self, approves:&Address, receiver: &Address, amount: U256) {}
}

pub(crate) struct MyTokenInstance;

#[no_mangle]
pub fn invoke() {
    // MyTokenDispatcher is auto generated by abi_codegen::contract，Implements automatic dispatch of contract requests and serialization of results
    let mut dispatcher = MyTokenDispatcher::new(MyTokenInstance);
    runtime::ret(&dispatcher.dispatch(&runtime::input()));
}

//The specific logic of the realization of the contract
impl MyToken for MyTokenInstance {
    fn initialize(&mut self, owner:&Address) -> bool {
        ///....
    }

    fn balance_of(&self, owner: &Address) -> U256 {
        //...
    }
    //... Implementation of other functions
}
```

## Contract test

If the test of the contract requires the developer to build a blockchain node and construct a large number of operations, such as the contract deployment and the invoke transaction, which are not related to the contract's own business, then such a test process is very inefficient and unreliable. `ontio_std::mock` is the contract's testing framework that provides a simulation of the api interaction with the chain, allowing contract developers to easily write contract test code without interacting with the actual chain.

To use the test function, you need to set the feature in Cargo.toml:
```toml
[features]
mock = ["ontio-std/mock"]
```
After writing the test case, run the contract test using `cargo test --features=mock`.
